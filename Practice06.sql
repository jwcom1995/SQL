SELECT *
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 ON(C1.CONSTRAINT_NAME=C2.CONSTRAINT_NAME)
WHERE C1.TABLE_NAME ='USER_UNIQUE3';

--제약 조건에 이름 설정
CREATE TABLE CONS_NAME(
	DATA1 NUMBER(10) CONSTRAINT NN_DATA1 NOT NULL,
	DATA2 VARCHAR2(20) CONSTRAINT NN_DATA2 UNIQUE,
	DATA3 VARCHAR2(20),
	CONSTRAINT UK_DATA3 UNIQUE(DATA3)
);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'CONS_NAME';

--CHECK 제약조건
--컬럼에 값을 기록할 때 지정한 값 이외에는 값이 기록되지 않도록
--범위를 제한하는 조건
--[사용형식]
--CHECK(컬럼명 비교연산자 값)
-- EX ) CHECK(GENDER IN ('M','F'))
-- EX ) CHECK(USER_ID IS NOT NULL)

CREATE TABLE USER_CHECK(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20),
	USER_PW VARCHAR2(30),
	USER_NAME VARCHAR2(15),
	GENDER CHAR(3) CHECK(GENDER IN ('남','여'))
);

INSERT INTO USER_CHECK
VALUES(1,'USER01','PASS01','이창진','남');

INSERT INTO USER_CHECK
VALUES(2,'USER02','PASS02','김유신','남자'); --CHECK 조건 SIZE 오버

INSERT INTO USER_CHECK
VALUES(2,'USER02','PASS02','김유신','M');	--CHECK 조건 값이 다름


INSERT INTO USER_CHECK
VALUES(2,'USER02','PASS02','김유신','여'); --정상작동

SELECT * FROM USER_CHECK;


--CHECK 제약조건에 부등호
CREATE TABLE USER_CHECK2(
	TEST_DATA NUMBER,
	CONSTRAINT CK_USERCK_DATA CHECK(TEST_DATA>0)
);

INSERT INTO USER_CHECK2 VALUES(10);
INSERT INTO USER_CHECK2 VALUES(-10); --CHECK 범위에 해당 X
SELECT * FROM USER_CHECK2;

CREATE TABLE USER_CHECK3(
	NAME VARCHAR2(15),
	PRICE NUMBER,
	CDATE DATE,
	QUAL CHAR(1),
	CONSTRAINT CK_CHECK3_PRICE CHECK(PRICE BETWEEN 1 AND 99999),
	CONSTRAINT CK_CHECK3_DATE CHECK(CDATE >= TO_DATE('2010/01/01','YYYY/MM/DD')),
	CONSTRAINT CK_CHECK3_QUAL CHECK(QUAL >= 'A' AND QUAL <= 'D')
);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'USER_CHECK3';

--제약조건 여러개를 설정하기
CREATE TABLE TEST_DUAL_CONS(
	TEST_NO NUMBER NOT NULL UNIQUE,
	TEST_NO2 NUMBER NOT NULL
);


--PRIMARY KEY 제약조건
--'기본키 제약조건'
--테이블 내의 한 행에서 그 행을 식별하기 위한 고유의 값을 가지는 컬럼
--NOT NULL과 UNIQUE 제약조건이 함께 걸어주는
--테이블 전체에 대한 각 데이터의 식별자 역활을 수행
--또한, 기본키 제약조건을 테입르마다 한 개 존재

CREATE TABLE USER_PK_TABLE(
	USER_NO NUMBER CONSTRAINT PK_USER_NO PRIMARY KEY,
	USER_ID VARCHAR2(20) UNIQUE,
	USER_PW VARCHAR2(20) NOT NULL,
	USER_NAME VARCHAR2(30) NOT NULL,
	GENDER CHAR(3) CHECK(GENDER IN ('남','여'))
);

SELECT * FROM USER_CONSTRAINTS
WHERE TABLE_NAME='USER_PK_TABLE';

INSERT INTO USER_PK_TABLE 
VALUES(1,'USER01','PASS01','이창진','남');

INSERT INTO USER_PK_TABLE 
VALUES(2,'USER02','PASS02','박창진','여');

SELECT * FROM USER_PK_TABLE;

--ORA-00001: unique constraint (KH.PK_USER_NO) violated
INSERT INTO USER_PK_TABLE 
VALUES(1,'USER03','PASS03','김창진','여');

--ORA-01400: cannot insert NULL into ("KH"."USER_PK_TABLE"."USER_NO")
INSERT INTO USER_PK_TABLE 
VALUES(NULL,'USER03','PASS03','김창진','여');

--기본키 제약조건을 여러 컬럼에 적용
CREATE TABLE USER_PK_TABLE2(
	USER_NO NUMBER,
	USER_ID VARCHAR2(20) UNIQUE,
	USER_PW VARCHAR2(20) NOT NULL,
	USER_NAME VARCHAR2(15) NOT NULL,
	CONSTRAINT PK_USER_NO2 PRIMARY KEY(USER_NO, USER_ID)
);

--1, 'USER01' : 성공
--2, 'USER02' : 성공
--1, 'USER03' : 성공
--2, 'USER01' : 실패!   --USER_ID UNIQUE조건에 부적합


-- 실습 1.
/* MEMBER 테이블을 생성하여
 사용자 정보를 받을 수 있는 테이블 객체를 만들되,
 회원 번호는 NUMBER형태로 기본키 설정하고,
 회원 아이디는 중복 불가에 필수 입력 사항으로,
 회원 비밀번호는 필수 입력 사항,
 회원 이름, 성별('M','F'), 회원 이메일, 연락처, 생년월일 정보를 받을수 있는
 컬럼을 가진 테이블을 생성하시오.
 단, 각 컬럼의 길이는 직접 판단하고, 위에 생성된 테이블 기준으로
 회원 정보를 최소 5개이상 삽입하여 확인하시오. 
*/
SELECT * FROM EMPLOYEE;
--DROP을 통해 객체 삭제
DROP TABLE MEMBER;
CREATE TABLE MEMBER(
	M_NO NUMBER CONSTRAINT PK_M_NO PRIMARY KEY,
	M_ID VARCHAR2(15) UNIQUE NOT NULL,
	M_PW VARCHAR2(30) NOT NULL,
	M_NAME VARCHAR2(15),
	GENDER CHAR(3) CHECK(GENDER IN ('M','F')),
	EMAIL VARCHAR(30),
	PHONE VARCHAR(30),
	BIRTH DATE
);


COMMENT ON COLUMN MEMBER.M_NO IS '회원번호';
COMMENT ON COLUMN MEMBER.M_ID IS '회원아이디';

INSERT INTO MEMBER
VALUES(1,'LSS1234','PASS01','이순신','M','LSS1234@naver.com','010-1234-1234',TO_DATE(640821));

INSERT INTO MEMBER
VALUES(2,'YGS1234','PASS02','유관순','F','YGS1234@google.com','010-1122-1234',TO_DATE(840318));

INSERT INTO MEMBER
VALUES(3,'HGD1234','PASS03','홍길동','M','HGD1234@naver.com','010-3333-1234',TO_DATE(820701));

INSERT INTO MEMBER
VALUES(4,'KYS1234','PASS04','김유신','M','KYS1234@google.com','010-2222-1234',TO_DATE(921117));

INSERT INTO MEMBER
VALUES(5,'KYA1234','PASS05','김연아','F','KYA1234@naver.com','010-4321-1244',TO_DATE(900427));

SELECT * FROM MEMBER;



--DML(데이터 조작 언어)
--INSERT, UPDATE, DELETE, SELECT --
--[ CRUD ]
-- C (CREATE) : INSERT/데이터추가
-- R (READ)   : SELECT/데이터조회
-- U (UPDATE) : UPDATE/데이터수정
-- D (DELETE) : DELETE/데이터삭제

-- INSERT : 새로운 행을 특정 테이블에 추가하는 명령어
--			실행 후에는 테이블의 행의 개수가 증가.

--[사용형식]
-- 1. 특정 컬럼에 값을 추가하는 방법
-- INSERT INTO 테이블명 [(컬럼명, ...)] VALUES(값1, ...);

-- 2. 모든 컬럼에 값을 추가하는 방법
-- INSERT INTO 테이블명 VALUES(값1,값2,...);

SELECT * FROM EMPLOYEE WHERE 1=2;
--컬럼을 명시하여 데이터 추가
INSERT INTO EMPLOYEE (EMP_ID, EMP_NAME, EMP_NO, EMAIL, PHONE, DEPT_CODE, JOB_CODE, SAL_LEVEL, SALARY,
					BONUS, MANAGER_ID,HIRE_DATE,ENT_DATE,ENT_YN)
VALUES(500,'변수빈','800101-1234567','subin@kh.or.kr','01011112222','D1','J7','S4',310000,0.1,'200',SYSDATE,NULL,DEFAULT);

SELECT * FROM EMPLOYEE WHERE EMP_NAME='변수빈';

--manager_id 삭제
INSERT INTO EMPLOYEE (EMP_ID, EMP_NAME, EMP_NO, EMAIL, PHONE, DEPT_CODE, JOB_CODE, SAL_LEVEL, SALARY,
					BONUS,HIRE_DATE,ENT_DATE,ENT_YN)
VALUES(501,'남혜림','900202-2234567','NAM@kh.or.kr','01022223333','D1','J7','S4',310000,0.2,SYSDATE,NULL,DEFAULT);

SELECT * FROM EMPLOYEE WHERE EMP_NAME='남혜림';

--컬럼 순서 변경
INSERT INTO EMPLOYEE (EMP_NAME,EMP_ID, EMP_NO, EMAIL, PHONE, DEPT_CODE, JOB_CODE, SAL_LEVEL, SALARY,
					BONUS, MANAGER_ID,HIRE_DATE,ENT_DATE,ENT_YN)
VALUES('공정화',502,'810303-1234567','gong@kh.or.kr','01015412222','D1','J7','S4',310000,0.1,'200',SYSDATE,NULL,DEFAULT);

SELECT * FROM EMPLOYEE WHERE EMP_NAME='공정화';

--컬럼을 생략하고 (모든 컬럼에 값을 추가)
INSERT INTO EMPLOYEE
VALUES(900,'이창현','880303-1458767','lee_ch@kh.or.kr','01044442222','D1','J7','S3',310000,0.2,'200',SYSDATE,NULL,DEFAULT);

SELECT * FROM EMPLOYEE;

--지금까지 변경된 내용을 실제 데이터베이스에 반영
COMMIT;

-- INSERT * SUBQUERY
-- INSERT문에 서브쿼리를 사용하여 VALUES 대신 값을 지정하여 추가할 수 있다.

CREATE TABLE EMP_01(
	EMP_ID NUMBER,
	EMP_NAME VARCHAR2(20),
	DEPT_TITLE VARCHAR2(40)
);

INSERT INTO EMP_01(
	SELECT EMP_ID,EMP_NAME,DEPT_TITLE
	FROM EMPLOYEE
	LEFT JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
);

SELECT * FROM EMP_01;

-----------
CREATE TABLE EMP_DEPT_D1
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
	FROM EMPLOYEE;

SELECT * FROM EMP_DEPT_D1;

DROP TABLE EMP_DEPT_D1;

-- 실습2
-- EMPLOYEE 테이블에서 D1 부서에 근무하는 직원들의
-- 사번, 이름, 부서코드, 입사일을 조회
-- EMP_DEPT_D1 테이블에 추가
INSERT INTO EMP_DEPT_D1(
	SELECT EMP_ID,EMP_NAME,DEPT_CODE,HIRE_DATE
	FROM EMPLOYEE
	WHERE DEPT_CODE = 'D1'
);
SELECT * FROM EMP_DEPT_D1;


--UPDATE : 해당 테이블의 데이터를 수정하는 명령어
--[사용형식]
--UPDATE 테이블명 SET 컬럼명 = 바꿀 값
--[WHERE 컬럼명 비교연산자 비교값]

CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

--D9번 부서를 총무부 -> 전략기획부
UPDATE DEPT_COPY 
SET DEPT_TITLE = '전략기획부'
WHERE DEPT_ID = 'D9';

COMMIT;

UPDATE DEPT_COPY 
SET DEPT_TITLE = '전략기획부'

--EMPLOYEE 테이블에서 사번이 200,201,214인 사원들의.
--해당 사원을 찾아 주민번호 앞자리를 '621130','631126','850705'로
--변경하는 UPDATE 구문을 작성

--잘못 표기된 사원 조회
SELECT EMP_ID,EMP_NO 
FROM EMPLOYEE
WHERE EMP_ID IN (200,201,214);

SELECT * FROM EMPLOYEE;
UPDATE EMPLOYEE
SET EMP_NO='621130'||SUBSTR(EMP_NO,7)
WHERE EMP_ID = '200';

UPDATE EMPLOYEE
SET EMP_NO='631126'||SUBSTR(EMP_NO,7)
WHERE EMP_ID = '201';

UPDATE EMPLOYEE
SET EMP_NO='850705'||SUBSTR(EMP_NO,7)
WHERE EMP_ID = '214';

ROLLBACK;

SELECT * FROM EMPLOYEE;

--UPDATE + SUBQUERY
-- 여러 행을 변경하거나, 여러 컬럼의 값을 변경 하고자 할 때 서브쿼리를 사용하여
-- UPDATE를 작성할 수 있다.
-- UPDATE 테이블명 SET 컬럼명 = (서브쿼리);

CREATE TABLE EMP_SALARY
AS SELECT EMP_ID,EMP_NAME,DEPT_CODE,SALARY,BONUS
	FROM EMPLOYEE;
	
SELECT * FROM EMP_SALARY
WHERE EMP_NAME IN ('유재식','방명수');

--유재식 사원과 같은 급여와 보너스를 받고 싶은 방명수 사원의
--급여,보너스를 변경하는 쿼리를 작성

--단일행 서브쿼리 사용
UPDATE EMP_SALARY
SET SALARY= (SELECT SALARY FROM EMP_SALARY WHERE EMP_NAME='유재식'),
	BONUS= (SELECT BONUS FROM EMP_SALARY WHERE EMP_NAME='유재식')
WHERE EMP_NAME='방명수';

SELECT * FROM EMP_SALARY
WHERE EMP_NAME IN('유재식','방명수');

--실습3
--노옹철, 전형돈, 하동운 사원의 급여를
--유재식 사우너과 같은 급여 ,보너스로 수정하는
--UPDATE 구문을 작성
--단,다중열 서브쿼리로 구현

UPDATE EMP_SALARY
SET SALARY = (SELECT SALARY FROM EMP_SALARY WHERE EMP_NAME='유재식'),
	BONUS = (SELECT BONUS FROM EMP_SALARY WHERE EMP_NAME='유재식')
WHERE EMP_NAME IN ('노옹철','전형돈','하동운');

SELECT * FROM EMP_SALARY
WHERE EMP_NAME IN ('노옹철','전형돈','하동운');

UPDATE EMP_SALARY SET BONUS=0.25
WHERE EMP_ID IN(
	SELECT EMP_ID FROM EMPLOYEE
	JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
	JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
	WHERE LOCAL_NAME LIKE 'ASIA%'
);

SELECT * FROM EMP_SALARY;

--UPDATE 시에 변경할 값이 해당 컬럼의 제약조건을 위배하지 않아야 한다.

--EMPLOYEE 테이블을 수정(제약조건 ADD, FOREIGN KEY)
ALTER TABLE EMPLOYEE ADD CONSTRAINT FK_DEPT FOREIGN KEY(DEPT_CODE) REFERENCES DEPARTMENT(DEPT_ID);

--ORA-02291: integrity constraint (KH.FK_DEPT) violated - parent key not found
UPDATE EMPLOYEE
SET DEPT_CODE ='D0'
WHERE DEPT_CODE ='D6';

SELECT * FROM EMPLOYEE WHERE DEPT_CODE = 'D0';


--DELETE 
--테이블에 있는 데이터를 삭제할 때 사용
--DELETE FROM 테이블명
--[WHERE 조건]; EMP_SALARY

SELECT * FROM EMP_SALARY;

DELETE FROM EMP_SALARY
WHERE EMP_ID=200;

DELETE FROM EMP_SALARY
WHERE EMP_ID=201;

DELETE FROM EMP_SALARY;