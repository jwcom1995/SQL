SELECT DECODE(SUBSTR(EMP_NO,8,1),1,'남성',2,'여성') 성별, COUNT(*)
FROM EMPLOYEE
GROUP BY SUBSTR(EMP_NO,8,1);

--HAVING--
--GROUP BY 한 각 소그룹에 대한 조건을 설정

SELECT DEPT_CODE, AVG(SALARY) 평균
FROM EMPLOYEE
WHERE SALARY > 3000000
GROUP BY DEPT_CODE;


SELECT DEPT_CODE, AVG(SALARY) 평균
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING AVG(SALARY) > 3000000;


--부서별 그룹의 합계 중 900만원을 초과하는
--부서의 코드와 급여 합계를 조회
SELECT  DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING SUM(SALARY)>9000000;

--실습 1
--급여 합계가 가장 높은 부서를 찾고
-- 해당 부서의 부서코드와 급여 합계를 조회

--1) 급여 합계가 가장 높은 부서의 급여합이 얼마인지 조회
SELECT MAX(SUM(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE;
--2) 급여 합계가 가장 높은 금여 합계와 같은 부서
SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING SUM(SALARY)=17700000;

--Sub Query
SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING SUM(SALARY)=(SELECT MAX(SUM(SALARY))
					FROM EMPLOYEE
					GROUP BY DEPT_CODE);

--SET OPERATOR(집합으로 연산처리 하는 것) --
--두 개 이상의 SELECT 한 결과를 합치거나,
--중복을 별도로 제거하거나 하는 집합형태의 결과로 조회하는 명령어

--RESULT SET = SELECT한 결과
				
--합집합
--UNION :
-- 두 개 이상의 SELECT한 결과를 구하는 명령어	
-- 두 개	이상의 결과를 보여주며 중복이 있을 경우 중복되는 결과는 1번만 보여준다.
--UNION ALL :
-- 두 개 이상의 SELECT 한 결과를 보여주되,
-- 중복이 있을 경우 중복되는 내용도 그대로 조회하여 보여준다.

--차집합
--MINUS:
-- 두 개 이상의 결과 중 첫번째 결과 만이 가지는 내용을 보여주는 명령어
			
--교집합
--INTERSECT:
-- 두 개 이상의 결과중 중복되는 결과만을 보여준다.

--*****비교하려는 두 Result set의 컬럼 개수가 같아야함
				
--UNION--
SELECT EMP_ID, EMP_NAME, DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5'
UNION
SELECT EMP_ID, EMP_NAME, DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE SALARY>3000000;

--UNION ALL--
SELECT EMP_ID, EMP_NAME, DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5'
UNION ALL
SELECT EMP_ID, EMP_NAME, DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE SALARY>3000000;

--교집합(INTERSECT)
SELECT EMP_ID, EMP_NAME, DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5'
INTERSECT
SELECT EMP_ID, EMP_NAME, DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE SALARY>3000000;

--차집합(MINUS)
SELECT EMP_ID, EMP_NAME, DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5'
MINUS 
SELECT EMP_ID, EMP_NAME, DEPT_CODE,SALARY
FROM EMPLOYEE
WHERE SALARY>3000000;

--JOIN--
--두 개 이상의 테이블을 하나로 합쳐 사용하는 명령어

--'J6'라는 직급을 가진 사원들의 근무 부서명 검색
SELECT EMP_NAME, JOB_CODE, DEPT_CODE
FROM EMPLOYEE
WHERE JOB_CODE ='J6';

SELECT DISTINCT DEPT_CODE
FROM EMPLOYEE
WHERE JOB_CODE = 'J6';

SELECT DEPT_ID, DEPT_TITLE
FROM DEPARTMENT
WHERE DEPT_ID IN('D1','D8');

--오라클 전용 문법 / ANSI표준 문법

--오라클
--FROM 절에 ',' 로 구분하여 합치게 도리 테이블을 나열
--WHERE 조건을 통해 합칠 테이블의 공통 사항을 명시해줘
--합친 뒤 그 결과를 조회하는 방식

SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;

SELECT EMP_ID, EMP_NAME, E.JOB_CODE, JOB_NAME
FROM EMPLOYEE E, JOB J 
WHERE E.JOB_CODE = J.JOB_CODE;

--ANSI 문법
--조인하고자 하는 테이블을 FROM 다음에 작성
--JOIN 테이블명 ON()	| USING() 구문을 사용하여
--두개이상의 테이블을 하나로 합치는 방법

SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID);

SELECT EMP_ID, EMP_NAME, E.JOB_CODE, JOB_NAME
FROM EMPLOYEE E
JOIN JOB J ON (E.JOB_CODE = J.JOB_CODE);

--USING()구문 사용
SELECT EMP_ID, EMP_NAME, E.JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);

--실습2
--EMPLOYEE 테이블의 직원 급여 정보와
--SAL_GRADE의 급여 등급을 합쳐서
--사번, 사원명,급여등급, 등급기준 최소급여, 최대급여를 조회

SELECT * FROM SAL_GRADE;
SELECT * FROM EMPLOYEE;
--ORACLE--
SELECT EMP_ID,EMP_NAME,e.SAL_LEVEL,MIN_SAL,MAX_SAL
FROM EMPLOYEE e, SAL_GRADE sg
WHERE e.SAL_LEVEL = sg.SAL_LEVEL;

--ANSI--
SELECT EMP_ID,EMP_NAME,SAL_LEVEL,MIN_SAL,MAX_SAL
FROM EMPLOYEE
JOIN SAL_GRADE USING(SAL_LEVEL);

SELECT EMP_ID,EMP_NAME,e.SAL_LEVEL,MIN_SAL,MAX_SAL
FROM EMPLOYEE e
JOIN SAL_GRADE sg on(e.SAL_LEVEL=sg.SAL_LEVEL);

--실습3
--DEPARTMENT 테이블의 위치 정보와
--LOCATION 테이블을 조인하여
--각 부서별 근무지 위치를 조회
--부서코드, 부서명, 근무지코드,근무지 위치

SELECT * FROM LOCATION;
SELECT * FROM DEPARTMENT;

--ORACLE-
SELECT DEPT_ID,DEPT_TITLE,LOCAL_CODE,NATIONAL_CODE
FROM DEPARTMENT,LOCATION
WHERE LOCATION_ID =LOCAL_CODE;

--ANSI--
SELECT DEPT_ID,DEPT_TITLE,LOCAL_CODE,NATIONAL_CODE
FROM DEPARTMENT
JOIN LOCATION ON(LOCATION_ID=LOCAL_CODE);

-- INNER JOIN / OUTER JOIN --
-- INNER : 둘 모두 일치하는 데이터만 합친다.
-- OUTER : 둘 중 하나, 혹은 둘 모두가 가진 값을 합칠때 사용

SELECT DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
ORDER BY 1;

SELECT DEPT_CODE FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;

--OUTER JOIN--
--LEFT [OUTER] JOIN : 두 테이블 중 원본 테이블의 정보를 모두 포함하여 조회할 때 선언
--RIGHT [OUTER] JOIN : JOIN에 명시한 테이블의 모든 정보를 포함하여 조회할 때 선언
--FULL [OUTER] JOIN : 두 테이블의 가진 데이터 중 서로가 가지지 않은 값일지라도 모두 포함하여 조회하고자 할 때 선언

--LEFT JOIN--
--ASNI
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID);
--ORACLE
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE,DEPARTMENT
WHERE DEPT_CODE=DEPT_ID(+);

--RIGHT JOIN--
--ANSI
SELECT DEPT_CODE, DEPT_ID, EMP_NAME
FROM EMPLOYEE
RIGHT JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID);
--ORACLE
SELECT DEPT_CODE, DEPT_ID, EMP_NAME
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE(+) =DEPT_ID;

--FULL JOIN--
--ANSI 
SELECT DEPT_CODE, DEPT_ID, EMP_NAME
FROM EMPLOYEE
FULL JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID);
--ORACLE (지원 안함)
--ORACLE 구문에서는 FULL OUTER JOIN을 지원하지 않는다.
SELECT DEPT_CODE, DEPT_ID, EMP_NAME
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE(+)=DEPT_ID(+);  --에러코드

--SELF JOIN--
--자기 자신을 조인하는 방법

--직원의 정보와 직원을 관리하는 매니저의 정보를 조회
SELECT * FROM EMPLOYEE;

--ANSI
SELECT E.EMP_ID , E.EMP_NAME ,E.MANAGER_ID ,M.EMP_NAME 
FROM EMPLOYEE E
JOIN EMPLOYEE M ON(E.MANAGER_ID= M.EMP_ID);
--ORACLE
SELECT E.EMP_ID , E.EMP_NAME ,E.MANAGER_ID ,M.EMP_NAME 
FROM EMPLOYEE E, EMPLOYEE M
WHERE E.MANAGER_ID =M.EMP_ID;

--다중 JOIN--
--여러개의 테이블을 JOIN
--일반, 조인과 선언방식은 같으나, 앞서 조인한 결과를 기준으로 후에 조인할 테이블을 조인한다.

--ANSI 
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE);  --순서 바뀌면 오류

--ORACLE
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE, DEPARTMENT,LOCATION
WHERE DEPT_CODE = DEPT_ID
	AND LOCATION_ID=LOCAL_CODE;
	
--실습 4
--직급이 대리이면서, 아시아 지역에서 근무하는 사원조회
--사번,사원명,직급명,부서명,근무지역명,급여
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
SELECT * FROM JOB;
--ANSI
SELECT EMP_ID,EMP_NAME,JOB_NAME,DEPT_TITLE,LOCAL_NAME,SALARY
FROM EMPLOYEE E
JOIN JOB J ON (E.JOB_CODE=J.JOB_CODE AND JOB_NAME='대리')
JOIN DEPARTMENT ON (DEPT_ID=DEPT_CODE)
JOIN LOCATION ON (LOCATION_ID=LOCAL_CODE AND LOCAL_NAME LIKE 'ASIA%');

--ORACLE
SELECT EMP_ID,EMP_NAME,JOB_NAME,DEPT_TITLE,LOCAL_NAME,SALARY
FROM EMPLOYEE E, DEPARTMENT,LOCATION,JOB J
WHERE E.JOB_CODE =J.JOB_CODE 
	AND DEPT_ID = DEPT_CODE 
	AND LOCATION_ID=LOCAL_CODE
	AND JOB_NAME='대리'
	AND LOCAL_NAME LIKE 'ASIA%';

--실습5
--한국(KO)과 일본(JP)에 근무하는 직원들의 정보를 조회
--사원명, 부서명, 지역명, 국가명
--WHERE 조건절을 통해 확인
SELECT * FROM NATIONAL;
SELECT * FROM LOCATION;
--ANSI 
SELECT EMP_NAME, DEPT_TITLE, L.LOCAL_NAME,N.NATIONAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID)
JOIN LOCATION L ON(LOCATION_ID=LOCAL_CODE)
JOIN NATIONAL N ON(L.NATIONAL_CODE =N.NATIONAL_CODE)
WHERE L.NATIONAL_CODE IN ('KO','JP');
--ORACLE
SELECT EMP_NAME, DEPT_TITLE, L.LOCAL_NAME,N.NATIONAL_NAME
FROM EMPLOYEE, DEPARTMENT, LOCATION L , NATIONAL N
WHERE DEPT_CODE=DEPT_ID
	AND LOCATION_ID=LOCAL_CODE
	AND L.NATIONAL_CODE=N.NATIONAL_CODE
	AND L.NATIONAL_CODE IN ('KO','JP');
	
SELECT EMP_NAME
FROM EMPLOYEE,DEPARTMENT;